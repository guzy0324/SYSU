/*
有一数组，求数组重排后能获得的最多不同位数。
1. 数组考虑sorted和unsorted结果是一样的。（相当于虚拟地址和实际地址
2. 对于无重复的sorted数组，可以做到每一位都不同。（错一位
3. 因为可能不只有一个数有重复，所以不妨用归纳法考虑。

归纳起点：对于无重复数组，可以做到每一位都不同。（1 + 2
考虑归纳假设：重排可以做到每一位都不同的数组a，并b（b1 == ... == bm且a1...n != b1）的情况。
因为a1...n != b1不妨将a中数字和b中数字做交换，即可做到不同
如果n >= m：a并b可以做到每一位都不同
如果n < m：a并b最多可以做到2 * n位不同，m - n位相同

考虑归纳假设：重排不可以做到每一位都不同的数组a，并b（b1 == ... == bm且a1...n != b1）的情况。
因为a1...n != b1不妨将a中数字和b中数字做交换，即可做到不同
如果n > m：情况复杂
如果n == m：a并b可以做到每一位都不同
如果n < m：a并b最多可以做到2 * n位不同，m - n位相同

以上说明结果和众数个数有关
对于重数b：如果2 * m > n + m，则最多可以做到2 * n位不同，m - n位相同
          如果2 * m == n + m，则可以做到每一位不同
          如果2 * m < n + m，若a重排可以做到每一位不同，则a并b可以做到每一位都不同
                            若a重排侯不可以做到每一位不同，则看a的众数b'

1. 2 * m > n + m：先a'和b'交换，再a和b交换，可以得到每一位都不同
2. 2 * m < n + m：递推到情况1

综上：
对于重数b：如果2 * m > n + m，则最多可以做到2 * n位不同，m - n位相同
          如果2 * m <= n + m，则可以做到每一位不同
所以如果有大于一半的数则众数大于一半则最多可以做到2 * n位不同
如果没有大于一半的数则众数小于一半则可以做到每一位不同
使用数字打架思想可结局大数据规模，时间O(n)空间O(n)
*/
#include<iostream>
#include<algorithm>
using namespace std;
int main() {
  int n, num, flag = 1, a[1000000], i, coun = 0;
  cin >> n;
  cin >> num;
  for (i = 0; i < n; i++) {
    cin >> a[i];
    flag += (a[i] == num) * 2 - 1;
    if (!flag) {
      flag = 1;
      num = a[i];
    }
  }
  for (i = 0; i < n; i++) {
    if (a[i] == num) {
      coun++;
    }
  }
  cout << n - coun + min(coun, n - coun);
}
